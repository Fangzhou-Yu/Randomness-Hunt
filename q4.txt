I approached this problem in the way below. First of all, we assume that human beings cannot generate
actually "random" sequences, I guess this is because human beings will be reluctant to write many
consecutive ones/zeros since it appears to be "not random" or some people may intentionally write
long consecutive zeros/ones for fun. So with this assumption, I perform four tests to check for randomness.

The first test is adopted from "Security Requirements for Cryptographic Modules" (as well as the third and
fourth). It's called "the monobit test", where we test the number of ones/zeros to make sure the ratio between
these two values falls in a reasonable range. The test is designed for 20,000 length sequences so I manually
scaled the range. See detail in my python file.
    For supplementary for test 1, 3, 4, see "testRandom.py"

The second test is based on the central limit theorem whereas the number of samples goes to infinity, the
distribution of results will become normal. I generated 1000 samples of 2800 length (to fit better the length
of sequences we are examining here). I stored the number of occurrences of all 16 possible combinations of each
four-bit segment and recorded the sample mean and variance and used that as a normal distribution, then I test
whether each sequence we have falls into a 95 confidence interval for each one of the 16 combinations. Turns out
that the sample size is too small and the variance is huge so I lowered the threshold to pass the test.
    For supplementary to this one, see "readBin.py", "getDistribution.py", "randBytes.c"

The third test is called the runs test, which counts of occurrences of consecutive ones and zeros. The model performs well
but due to a similar problem as problem 2, few samples manages to pass all tests (define pass as the occurrences of a 
specific number of consecutive ones/zeros falls into an interval). So I made a slight change so that if the sample
passes two out of three tests, then it is deemed successful.

The fourth test is called the long run test. Which fails if too many consecutive ones and zeros occur. I made the
outcome of this test definitive as to whether the sequence will be deemed not random, which means if a sequence fails this
test than it is absolutely not random in my definition. Since the implementation is rather similar to that of test 3,
it is done while we inspect the data set in q3.

Now the result has yielded 26 machine generated sequences (sequences that pass at least three out of the four tests 
above). So I decide to manually drop one of them. Unfortunately, the sequence generated by myself has been identified
correctly as generated by a human, so I will have to look into it.

After looking into the sequencies, sequence 32 is the longest, i.e, the distribution of it is more likely to be normal,
while it only passes 3 tests, not 4, so I decide to manually drop seuqence 32 and deem it as generated by human.

See result in Q4result.txt